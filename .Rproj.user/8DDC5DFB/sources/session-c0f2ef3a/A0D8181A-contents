
# Color palette for discrete groups
col21 <- rev(c("tomato1","darkblue","turquoise1","lightblue","darkred","mediumblue","purple","bisque",
               "greenyellow","yellow","violetred2","darkgreen","darkgoldenrod1","deeppink3","cadetblue4",
               "orchid2","seagreen3","purple4","dodgerblue2","red","gray27"))

#' Load Alpha and Beta Diversity Metrics
#'
#' This function reads a metadata file and all alpha and beta diversity metrics
#' from a specified directory. It merges metadata with alpha diversity metrics
#' in long format and loads beta diversity metrics as distance matrices.
#'
#' @param metadata_csv Path to the metadata CSV file. Must contain a column named \code{sampleID} matching to diversity metrics
#' @param diversity_path Path to the directory containing diversity metric files.
#'
#' @details
#' The function expects alpha diversity metrics to have file names ending with:
#' \itemize{
#'   \item \code{richness.tsv}
#'   \item \code{shannon.tsv}
#'   \item \code{chao1.tsv}
#'   \item \code{invsimpson.tsv}
#' }
#'
#' Beta diversity metrics must have file names ending with:
#' \itemize{
#'   \item \code{jaccard.tsv}
#'   \item \code{weighted-unifrac.tsv}
#'   \item \code{unweighted-unifrac.tsv}
#'   \item \code{bray-curtis.tsv}
#' }
#'
#' Alpha diversity files will be combined into a single long-format data frame.
#' Beta diversity files are read as symmetric matrices and converted to \code{dist} objects.
#'
#' @return A list with three components:
#' \describe{
#'   \item{\code{metadata}}{A data frame of sample metadata.}
#'   \item{\code{alpha}}{A long-format data frame with alpha diversity metrics (columns: sampleID, other metadata columns, Metric, Value).}
#'   \item{\code{beta}}{A named list of beta diversity distance matrices (as \code{dist} objects).}
#' }
#'
#' @examples
#' \dontrun{
#' diversity_data <- load_diversity_metrics(
#'   metadata_csv = "metadata.csv",
#'   diversity_path = "diversity_results/"
#' )
#'
#' # Access metadata
#' head(diversity_data$metadata)
#'
#' # Access alpha diversity
#' head(diversity_data$alpha)
#'
#' # Access beta diversity distance matrices
#' names(diversity_data$beta)
#' }
#'
#' @importFrom readr read_csv
#' @importFrom stringr str_ends str_remove
#' @importFrom tidyr pivot_longer
#' @importFrom tibble rownames_to_column
#' @importFrom dplyr merge
#' @export
load_diversity_metrics <- function(metadata_csv, diversity_path) {

  # ------------------------------
  # 1. Load metadata
  # ------------------------------
  metadata <- read_csv(metadata_csv, show_col_types = FALSE)
  if (!"sampleID" %in% colnames(metadata)) {
    stop("metadata must contain a column named 'sampleID'")
  }
  rownames(metadata) <- metadata$sampleID
  
  # ------------------------------
  # 2. Get all .tsv files in folder
  # ------------------------------
  all_files <- list.files(diversity_path, pattern = "\\.tsv$", full.names = TRUE)
  
  # ------------------------------
  # 3. Identify Alpha and Beta files by suffix
  # ------------------------------
  alpha_suffixes <- c("richness.tsv", "shannon.tsv","chao1.tsv","invsimpson.tsv")
  beta_suffixes  <- c("jaccard.tsv", "weighted-unifrac.tsv",
                      "unweighted-unifrac.tsv", "bray-curtis.tsv")
  
  alpha_files <- all_files[sapply(all_files, function(f) any(str_ends(f, alpha_suffixes)))]
  beta_files  <- all_files[sapply(all_files, function(f) any(str_ends(f, beta_suffixes)))]
  
  # ------------------------------
  # 4. Load Alpha Diversity (wide â†’ long format)
  # ------------------------------
  alpha_list <- lapply(alpha_files, function(file) {
    df <- read.table(file, header = TRUE, sep = "\t", check.names = FALSE) %>%
      as.data.frame() %>%
      rownames_to_column(var = 'sampleID')
    return(df)
  })
  
  alpha <- Reduce(function(x, y) merge(x, y, by = 'sampleID', all = TRUE), alpha_list) %>%
    merge(metadata, ., by = 'sampleID', all.x = TRUE) %>%
    pivot_longer(cols = setdiff(colnames(.), colnames(metadata)),
                 names_to = "Metric",
                 values_to = "Value")
  
  # ------------------------------
  # 5. Load Beta Diversity (distance matrices)
  # ------------------------------
  beta_list <- lapply(beta_files, function(file) {
    df <- read.table(file, header = TRUE, sep = "\t", check.names = FALSE)
    if(!is.numeric(df[[1]])) {
      rownames(df) <- df[[1]]
      df = df[,-1]
    }
    mtx <- as.matrix(df)
    
    # Check row/column names
    if (!all(rownames(mtx) == colnames(mtx))) {
      stop("Distance matrix row and column names do not match in file: ", file)
    }
    return(mtx)
  })
  
  # Clean names: remove .tsv
  names(beta_list) <- basename(beta_files) %>%
    str_remove("\\.tsv$") %>%
    str_remove("metaphlan_bugs_list_")
  
  # ------------------------------
  # Return everything as a list
  # ------------------------------
  return(list(
    metadata = metadata,
    alpha = alpha,
    beta = beta_list
  ))
}


#' Plot Alpha Diversity Metrics by Group
#'
#' Creates violin or scatter plots of alpha diversity metrics depending on whether
#' the grouping variable is numeric or categorical.
#'
#' @param df A long-format data frame of alpha diversity metrics, typically from `load_alpha_diversity()`.
#' @param group_by The name (string) of the column in `df` to group by.
#'
#' @return A ggplot object.
#'
#' @import ggplot2 dplyr ggpubr
#' @export
plot_alpha_diversity <- function(df, group_by) {

  
  # Validate inputs
  if (!group_by %in% colnames(df)) {
    stop(paste("Column", group_by, "not found in input data frame."))
  }
  
  # Determine type of grouping variable
  is_numeric_group <- is.numeric(df[[group_by]])
  
  # Generate plot
  if (is_numeric_group) {
    p <- ggplot(df, aes(x = .data[[group_by]], y = Value)) +
      geom_point(alpha = 0.6, color = "black") +
      geom_smooth(method = "lm", se = FALSE, color = "steelblue") +
      facet_wrap(~Metric, scales = "free_y") +
      labs(x = group_by, y = "Value", title = paste0("Alpha Diversity by ",group_by)) +
      theme_pubr(base_size = 10)
  } else {
    p <- ggplot(df, aes(x = .data[[group_by]], y = Value, fill = .data[[group_by]])) +
      geom_violin(trim = FALSE,alpha = 0.5) +
      geom_boxplot(width = 0.1, fill = "white", outlier.size = 0.5) +
      facet_wrap(~Metric, scales = "free_y") +
      labs(x = " ", y = "Value", title = paste0("Alpha Diversity by ",group_by)) +
      theme_pubr(base_size = 14) +
      theme(axis.text.x = element_text(angle = 20, hjust = 1),
            legend.position = "none")
  }
  
  return(plotly::ggplotly(p))
}

#' Plot PCoA with UniFrac or other distance metrics
#'
#' Creates a Principal Coordinates Analysis (PCoA) plot from a distance matrix
#' and associated metadata, with options for PERMANOVA and PERMDISP tests and both discrete
#' and continuous groupings.
#'
#' @param dm A distance matrix (`dist` object or matrix).
#' @param metatable A data frame of metadata containing \code{sampleID} and the grouping variables.
#' @param grp A character string specifying the grouping variable (column) in \code{metatable}.
#' @param dm_name A character string for naming the distance metric (used in plot title).
#' @param permtest Logical; if TRUE, performs PERMANOVA (adonis2) and betadispersion tests.
#' @param grp_continuous Logical; if TRUE, treats the grouping variable as continuous for coloring. Default is false. It will be
#' automatically determined based on the property of the column
#'
#' @details
#' The function uses \code{\link[ape]{pcoa}} for PCoA calculation (with Cailliez correction for negative eigenvalues)
#' and \code{\link[ggplot2]{ggplot}} for visualization. PERMANOVA and betadispersion tests require the \pkg{vegan} package.
#'
#' @return A ggplot object showing the first two PCoA axes with explained variance.
#'
#' @examples
#' \dontrun{
#' plot_unifrac(dist_mtx, metadata, "Management", "Bray-Curtis")
#' }
#'
#' @import ape vegan ggplot2 dplyr scales viridis
#' @export
plot_beta_pcoa <- function(dm, metatable, grp, dm_name, permtest = FALSE, grp_continuous = FALSE) {
  set.seed(666)
  
  # Ensure metadata format
  metatable <- as.data.frame(metatable)
  rownames(metatable) <- metatable$sampleID
  metatable <- subset(metatable, get(grp) != "N.A.", select = c(grp))
  if (is.numeric(metatable[[grp]])) grp_continuous <- TRUE
  #print(paste0(grp,'test'))
  # Subset distance matrix
  #print(head(dm))
  dm <- dist_subset(dm, rownames(metatable))
  
  # PCoA with Cailliez correction for negative eigenvalues
  pcoa_res <- ape::pcoa(dm, correction = "cailliez")
  coords <- data.frame(pcoa_res$vectors, check.names = FALSE)
  
  # PERMANOVA & betadisp tests
  group_counts <- table(metatable[[grp]])
  subtitle <- "Adonis/permdisp skipped"
  if (!any(group_counts < 5) && permtest) {
    stopifnot(all(rownames(metatable) == names(dm)))
    adonis_res <- vegan::adonis2(as.formula(paste("dm ~", grp)), data = metatable, permutations = 1000)
    adonis_p <- round(adonis_res$`Pr(>F)`[1], 4)
    betadisp_res <- vegan::permutest(vegan::betadisper(dm, metatable[[grp]]),
                                     permutations = 1000)
    betadisp_p <- round(betadisp_res$tab[[6]][1], 4)
    subtitle <- paste0("PERMANOVA p = ", adonis_p, ", Betadisp p = ", betadisp_p)
  }
  
  if (!all(rownames(metatable) == rownames(coords))) {
    stop("Mismatch between PCoA coordinates and metadata rows")
  }
  
  # Prepare data for plotting
  plot_data <- coords[, c(1, 2)]
  plot_data[[grp]] <- metatable[[grp]][match(rownames(plot_data), rownames(metatable))]
  
  centroids <- plot_data %>%
    group_by_at(grp) %>%
    summarize(CentroidX = mean(Axis.1), CentroidY = mean(Axis.2), .groups = "drop")
  plot_data <- merge(plot_data, centroids, by = grp)
  
  # Explained variance
  pc_exp <- if ("Rel_corr_eig" %in% colnames(pcoa_res$values)) {
    pcoa_res$values$Rel_corr_eig
  } else {
    pcoa_res$values$Relative_eig
  }
  
  # Plot: Discrete vs Continuous
  if (!grp_continuous) {
    pcoa_plot <- ggplot() +
      geom_point(data = plot_data,
                 aes(x = Axis.1, y = Axis.2, colour = get(grp)),
                 alpha = 0.6, size = 0.8) +
      geom_segment(data = plot_data,
                   aes(x = CentroidX, xend = Axis.1, y = CentroidY, yend = Axis.2,
                       color = get(grp)), alpha = 0.3, size = 0.3) +
      geom_point(data = centroids,
                 aes(x = CentroidX, y = CentroidY, fill = get(grp)),
                 size = 4, shape = 21, stroke = 1.2, color = "black") +
      labs(title = paste0(dm_name, ": ", grp), subtitle = subtitle) +
      xlab(paste0("PC1 (", label_percent()(pc_exp[1]), ")")) +
      ylab(paste0("PC2 (", label_percent()(pc_exp[2]), ")")) +
      theme(panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            axis.line = element_line(colour = "black"),
            legend.position = "top",
            legend.title = element_blank(),
            legend.text = element_text(size = 8, face = "bold"),
            axis.text = element_text(size = 12),
            axis.title = element_text(size = 14, face = "bold")) +
      scale_color_manual(values = col21) +
      scale_fill_manual(values = col21)
  } else {
    pcoa_plot <- ggplot() +
      geom_point(data = plot_data,
                 aes(x = Axis.1, y = Axis.2, colour = !!sym(grp)),
                 alpha = 0.6, size = 1.2) +
      labs(title = paste0(dm_name, ": ", grp), subtitle = subtitle) +
      xlab(paste0("PC1 (", label_percent()(pc_exp[1]), ")")) +
      ylab(paste0("PC2 (", label_percent()(pc_exp[2]), ")")) +
      theme(panel.grid.major = element_blank(),
            panel.grid.minor = element_blank(),
            panel.background = element_blank(),
            axis.line = element_line(colour = "black"),
            legend.position = "top",
            legend.title = element_blank(),
            legend.text = element_text(size = 8, face = "bold"),
            axis.text = element_text(size = 12),
            axis.title = element_text(size = 14, face = "bold")) +
      scale_color_viridis_c(option = "plasma")
  }
  
  return(pcoa_plot)
}
